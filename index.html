
<!--
https://websim.ai/c/6VtVN0iSDlDgV3BIR 
Continue development on websim on new prompt with:
- See if you can start a web app from this code, leave the code as is... It already works.

Interesting prompts:
1. Place holes in the floor that you must jump to get over.   Also oscillating orbs of light in the path.
2. Now, the holes must be full of lethal lava.   The orbs must have different colors and they have to follow you very slowly. 

Creating an Orb:
https://chatgpt.com/c/66ebd04b-91c8-8005-be45-a9c56f4aa07c
-->
<html>
<head>
    <title>3D Labyrinth Explorer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #menu, #instructions {
            position: absolute; background: rgba(0,0,0,0.7); color: white;
            padding: 10px; border-radius: 5px;
        }
        #menu { top: 10px; left: 10px; }
        #instructions { bottom: 10px; left: 10px; }
        button {
            margin: 5px; padding: 5px 10px; background: #4CAF50; color: white;
            border: none; border-radius: 3px; cursor: pointer;
        }
        button:hover { background: #45a049; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.module.js",
            "PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js",
            "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/ShaderPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/ShaderPass.js",
            "three/examples/jsm/postprocessing/UnrealBloomPass": "three/examples/jsm/postprocessing/UnrealBloomPass.js"
        }
    }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>
    <div id="menu" onclick="event.stopImmediatePropagation()">
        <button id="generateBtn">Generate New Labyrinth</button>
        <button id="saveBtn">Save Labyrinth</button>
        <button id="loadBtn">Load Labyrinth</button>
        <button id="toggleCollisionBtn">Disable Collision</button>
        <input type="file" id="fileInput" style="display:none;">
    </div>
    <div id="instructions">
        <p>Click to start | WASD or Arrow Keys: Move | Mouse: Look | Shift: Run | Space: Jump | ESC: Release mouse</p>
    </div>
    <script type="module">
        import * as game from "./game.js";
        class Config extends game.DefaultConfig {
            static PLAYER_RADIUS = 1.1;
            static TIME_STEP = 1 / 60;
        }
        game.setConfig(Config);
        class Game extends game.Game {
            /*
            constructor() {
                super(false);
                this.posprocess = this.getPostprocessingRenderer();
                this.animate();
            }
            render(){
                this.posprocess();
            }
            */
            getPostprocessingRenderer() {
                const composer = new EffectComposer(this.renderer);
                
                const lightSources = [];
                this.scene.traverse((object) => {
                    if (object.isLight) {
                        lightSources.push(object);
                    }
                });
                
                const renderPass = new RenderPass(this.scene, this.camera);
                composer.addPass(renderPass);

                // Initialize the lightScreenPositions array with MAX_LIGHTS Vector2 instances
                const lightScreenPositions = [];
                for (let i = 0; i < Config.MAX_LIGHTS; i++) {
                    lightScreenPositions.push(new THREE.Vector2(0, 0));
                }

                const godraysPass = new ShaderPass(MultiLightGodRaysShader);
                godraysPass.uniforms.lightScreenPositions.value = lightScreenPositions;
                composer.addPass(godraysPass);

                return () => {
                    const numLights = Math.min(lightSources.length, Config.MAX_LIGHTS);

                    for (let i = 0; i < numLights; i++) {
                        const light = lightSources[i];

                        const vector = new THREE.Vector3();
                        vector.setFromMatrixPosition(light.matrixWorld);
                        vector.project(this.camera);

                        lightScreenPositions[i].set(
                            (vector.x + 1) / 2,
                            (vector.y + 1) / 2
                        );
                    }

                    // Set unused light positions to (0, 0)
                    for (let i = numLights; i < Config.MAX_LIGHTS; i++) {
                        lightScreenPositions[i].set(0, 0);
                    }

                    godraysPass.uniforms.numLights.value = numLights;

                    composer.render();
                };
            }

        }

        // The updated MultiLightGodRaysShader
        const MultiLightGodRaysShader = {
            uniforms: {
                tDiffuse: { value: null },
                lightScreenPositions: { value: [] },
                numLights: { value: 0 },
                density: { value: 0.96 },
                decay: { value: 0.93 },
                weight: { value: 0.4 },
                exposure: { value: 0.6 },
            },
            vertexShader: `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,
            fragmentShader: `
                #define MAX_LIGHTS ${Config.MAX_LIGHTS}
                #define NUM_SAMPLES ${Config.NUM_SAMPLES}

                uniform sampler2D tDiffuse;
                uniform vec2 lightScreenPositions[MAX_LIGHTS];
                uniform int numLights;
                uniform float density;
                uniform float decay;
                uniform float weight;
                uniform float exposure;

                varying vec2 vUv;

                void main() {
                    vec4 sceneColor = texture2D(tDiffuse, vUv);
                    vec3 godrayColor = vec3(0.0);

                    for (int i = 0; i < MAX_LIGHTS; i++) {
                        if (i >= numLights) break;

                        vec2 lightPos = lightScreenPositions[i];

                        vec2 deltaTextCoord = lightPos - vUv;
                        vec2 textCoord = vUv;
                        float illuminationDecay = 1.0;

                        for (int j = 0; j < NUM_SAMPLES; j++) {
                            textCoord += deltaTextCoord * (density / float(NUM_SAMPLES));
                            vec4 sampleColor = texture2D(tDiffuse, textCoord);
                            sampleColor *= illuminationDecay * weight;
                            godrayColor += sampleColor.rgb;
                            illuminationDecay *= decay;
                        }
                    }

                    vec3 finalColor = sceneColor.rgb + godrayColor * exposure;
                    gl_FragColor = vec4(finalColor, sceneColor.a);
                }
            `,
        };        
        new game.Game();
    </script>
</body>
</html>