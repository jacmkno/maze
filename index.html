<html><head><base href="https://example.com"><title>3D Labyrinth Explorer</title><style>
    body { 
        margin: 0; 
        overflow: hidden; 
        font-family: Arial, sans-serif; 
    }
    canvas { 
        display: block; 
    }
    #menu {
        position: absolute;
        top: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
    }
    button {
        margin: 5px;
        padding: 5px 10px;
        background: #4CAF50;
        color: white;
        border: none;
        border-radius: 3px;
        cursor: pointer;
    }
    button:hover {
        background: #45a049;
    }
    #instructions {
        position: absolute;
        bottom: 10px;
        left: 10px;
        background: rgba(0,0,0,0.7);
        color: white;
        padding: 10px;
        border-radius: 5px;
    }
</style></head><body>
    <div id="menu">
        <button id="generateBtn">Generate New Labyrinth</button>
        <button id="saveBtn">Save Labyrinth</button>
        <button id="loadBtn">Load Labyrinth</button>
        <button id="toggleCollisionBtn">Disable Collision</button>
        <input type="file" id="fileInput" style="display:none;">
    </div>
    <div id="instructions">
        <p>Click to start | WASD or Arrow Keys: Move | Mouse: Look | Shift: Run | Space: Jump | ESC: Release mouse</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
    <script>
        let scene, camera, renderer, controls, labyrinth, player;
        let world, playerBody, floorBody, wallBodies = [];
        const CELL_SIZE = 10, WALL_HEIGHT = 5, LABYRINTH_SIZE = 20;
        const WALK_SPEED = 150, RUN_SPEED = 300, JUMP_HEIGHT = 20, GRAVITY = 30;
        const PLAYER_HEIGHT = 2, PLAYER_RADIUS = 1.1, COLLISION_MARGIN = 0.3;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false, sprint = false, canJump = false, collisionEnabled = true;
        let prevTime = performance.now(), velocity = new THREE.Vector3(), direction = new THREE.Vector3();
        const timeStep = 1 / 60;
        let matrix;

        function init() {
            try {
                setupScene();
                setupPhysics();
                setupPlayer();
                setupEventListeners();
                drawLabyrinth();
                resetPlayerPosition();
                animate();
                window.addEventListener('resize', onWindowResize, false);
                console.log("Initialization complete");
            } catch (error) {
                console.error("Error during initialization:", error);
            }
        }

        function setupScene() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 0, 500);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x87CEEB);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);
            
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(50, 100, 50);
            light.castShadow = true;
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(0, 0, -5);
            scene.add(cube);

            console.log("Scene setup complete");
        }

        function setupPhysics() {
            world = new CANNON.World();
            world.gravity.set(0, -GRAVITY, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;

            const groundMaterial = new CANNON.Material('groundMaterial');
            const playerMaterial = new CANNON.Material('playerMaterial');
            const wallMaterial = new CANNON.Material('wallMaterial');
            const playerGroundContact = new CANNON.ContactMaterial(groundMaterial, playerMaterial, {
                friction: 0.8,
                restitution: 0.3
            });
            world.addContactMaterial(playerGroundContact);

            const playerWallContact = new CANNON.ContactMaterial(wallMaterial, playerMaterial, {
                friction: 0.8,
                restitution: 0.3
            });
            world.addContactMaterial(playerWallContact);
        }

        function setupPlayer() {
            player = new THREE.Group();
            scene.add(player);
            camera.position.set(0, PLAYER_HEIGHT, 0);
            player.add(camera);
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());

            const playerShape = new CANNON.Sphere(PLAYER_RADIUS);
            playerBody = new CANNON.Body({
                mass: 5,
                shape: playerShape,
                material: new CANNON.Material('playerMaterial'),
                linearDamping: 0.9,
                angularDamping: 0.9
            });
            playerBody.position.set(0, PLAYER_HEIGHT, 0);
            world.addBody(playerBody);
        }

        function setupEventListeners() {
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', () => controls.lock());
            controls.addEventListener('lock', () => document.getElementById('instructions').style.display = 'none');
            controls.addEventListener('unlock', () => document.getElementById('instructions').style.display = 'block');
            document.getElementById('generateBtn').addEventListener('click', () => drawLabyrinth());
            document.getElementById('saveBtn').addEventListener('click', saveLabyrinth);
            document.getElementById('loadBtn').addEventListener('click', () => document.getElementById('fileInput').click());
            document.getElementById('fileInput').addEventListener('change', loadLabyrinth);
            document.getElementById('toggleCollisionBtn').addEventListener('click', toggleCollision);
        }

        function generateLabyrinth(seed = null, width=20, height=20) {
            function neighbors(maze, ic, jc) {
                var final = [];
                for (var i = 0; i < 4; i++) {
                    var n = [ic, jc];
                    n[i % 2] += ((Math.floor(i / 2) * 2) || -2);
                    if (n[0] < maze.length && 
                        n[1] < maze[0].length && 
                        n[0] > 0 && 
                        n[1] > 0) {
                        
                        if (maze[n[0]][n[1]] == 1) {
                            final.push(n);
                        }
                    }
                }
                return final;
            }

            width -= width % 2; width++;
            height -= height % 2; height++;
            
            var maze = [];
            for (var i = 0; i < height; i++) {
                maze.push([]);
                for (var j = 0; j < width; j++) {
                    maze[i].push(1);
                }
            }
            
            maze[0][1] = 0;
            
            var start = [];
            do {
                start[0] = Math.floor(Math.random() * height)
            } while (start[0] % 2 == 0);
            do {
                start[1] = Math.floor(Math.random() * width)
            } while (start[1] % 2 == 0);
            
            maze[start[0]][start[1]] = 0;
            var openCells = [start];
            
            while (openCells.length) {
                var cell, n;
                openCells.push([-1, -1]);
                do {
                    openCells.pop();
                    if (openCells.length == 0)
                        break;
                    cell = openCells[openCells.length - 1];
                    n = neighbors(maze, cell[0], cell[1]);
                } while (n.length == 0 && openCells.length > 0);
                
                if (openCells.length == 0)
                    break;
                
                var choice = n[Math.floor(Math.random() * n.length)];
                openCells.push(choice);
                maze[ choice[0] ][ choice[1] ] = 0;
                maze[ (choice[0] + cell[0]) / 2 ][ (choice[1] + cell[1]) / 2 ] = 0;
            }

            // Add lava holes to the maze
            for (let i = 1; i < height - 1; i += 2) {
                for (let j = 1; j < width - 1; j += 2) {
                    if (maze[i][j] === 0 && Math.random() < 0.1) {
                        maze[i][j] = 2; // 2 represents a lava hole
                    }
                }
            }
            
            maze[maze.length - 1][maze[0].length - 2] = 0;
            maze[maze.length - 2][maze[0].length - 2] = 0;
            
            return maze;
        }

        function setupFloor() {
            const floorGeometry = new THREE.PlaneGeometry(CELL_SIZE, CELL_SIZE);
            const floorTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/hardwood2_diffuse.jpg');
            floorTexture.wrapS = THREE.RepeatWrapping;
            floorTexture.wrapT = THREE.RepeatWrapping;
            floorTexture.repeat.set(1, 1);

            const floorMaterial = new THREE.MeshPhongMaterial({ map: floorTexture });

            for (let i = 0; i < LABYRINTH_SIZE; i++) {
                for (let j = 0; j < LABYRINTH_SIZE; j++) {
                    if (matrix[i][j] !== 2) {
                        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                        floor.rotation.x = -Math.PI / 2;
                        floor.position.set(i * CELL_SIZE + CELL_SIZE / 2, 0, j * CELL_SIZE + CELL_SIZE / 2);
                        floor.receiveShadow = true;
                        labyrinth.add(floor);

                        const floorShape = new CANNON.Plane();
                        const floorBody = new CANNON.Body({
                            mass: 0,
                            shape: floorShape,
                            material: new CANNON.Material('groundMaterial')
                        });
                        floorBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                        floorBody.position.set(i * CELL_SIZE + CELL_SIZE / 2, 0, j * CELL_SIZE + CELL_SIZE / 2);
                        world.addBody(floorBody);
                    }
                }
            }
        }

        function createLightOrbs() {
            const orbGeometry = new THREE.SphereGeometry(0.5, 32, 32);
            const orbColors = [0xffff00, 0x00ffff, 0xff00ff, 0x00ff00, 0xff0000, 0x0000ff];

            for (let i = 0; i < LABYRINTH_SIZE; i++) {
                for (let j = 0; j < LABYRINTH_SIZE; j++) {
                    if (matrix[i][j] === 0 && Math.random() < 0.1) {
                        const orbMaterial = new THREE.MeshBasicMaterial({ color: orbColors[Math.floor(Math.random() * orbColors.length)] });
                        const orb = new THREE.Mesh(orbGeometry, orbMaterial);
                        orb.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, j * CELL_SIZE + CELL_SIZE / 2);
                        labyrinth.add(orb);

                        const light = new THREE.PointLight(orbMaterial.color, 1, CELL_SIZE * 2);
                        light.position.copy(orb.position);
                        labyrinth.add(light);

                        orb.userData = {
                            initialY: orb.position.y,
                            light: light
                        };
                    }
                }
            }
        }

        function drawLabyrinth(inputMatrix = null) {
            matrix = inputMatrix ?? generateLabyrinth();
            if (labyrinth) scene.remove(labyrinth);
            labyrinth = new THREE.Group();
            scene.add(labyrinth);

            const wallGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT, CELL_SIZE);
            const wallTexture = new THREE.TextureLoader().load('https://threejs.org/examples/textures/brick_diffuse.jpg');
            const wallMaterial = new THREE.MeshPhongMaterial({ map: wallTexture });

            const lavaGeometry = new THREE.BoxGeometry(CELL_SIZE, WALL_HEIGHT / 2, CELL_SIZE);
            const lavaMaterial = new THREE.MeshPhongMaterial({
                color: 0xff4500,
                emissive: 0xff0000,
                specular: 0xffff00,
                shininess: 50,
                transparent: true,
                opacity: 0.8
            });

            for (let i = 0; i < LABYRINTH_SIZE; i++) {
                for (let j = 0; j < LABYRINTH_SIZE; j++) {
                    if (matrix[i][j] === 1) {
                        const wall = new THREE.Mesh(wallGeometry, wallMaterial);
                        wall.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, j * CELL_SIZE + CELL_SIZE / 2);
                        wall.castShadow = true;
                        wall.receiveShadow = true;
                        labyrinth.add(wall);

                        const wallShape = new CANNON.Box(new CANNON.Vec3(CELL_SIZE / 2, WALL_HEIGHT / 2, CELL_SIZE / 2));
                        const wallBody = new CANNON.Body({
                            mass: 0,
                            shape: wallShape,
                            material: new CANNON.Material('wallMaterial')
                        });
                        wallBody.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 2, j * CELL_SIZE + CELL_SIZE / 2);
                        world.addBody(wallBody);
                        wallBodies.push(wallBody);
                    } else if (matrix[i][j] === 2) {
                        const lava = new THREE.Mesh(lavaGeometry, lavaMaterial);
                        lava.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 4, j * CELL_SIZE + CELL_SIZE / 2);
                        labyrinth.add(lava);

                        const lavaShape = new CANNON.Box(new CANNON.Vec3(CELL_SIZE / 2, WALL_HEIGHT / 4, CELL_SIZE / 2));
                        const lavaBody = new CANNON.Body({
                            mass: 0,
                            shape: lavaShape,
                            material: new CANNON.Material('lavaMaterial')
                        });
                        lavaBody.position.set(i * CELL_SIZE + CELL_SIZE / 2, WALL_HEIGHT / 4, j * CELL_SIZE + CELL_SIZE / 2);
                        world.addBody(lavaBody);
                        lavaBody.collisionResponse = true;
                        lavaBody.addEventListener("collide", handleLavaCollision);
                    }
                }
            }

            setupFloor();
            createLightOrbs();
            resetPlayerPosition();
            console.log("Labyrinth generated:", matrix);
            console.log("Labyrinth added to scene");
        }

        function handleLavaCollision(event) {
            if (event.body === playerBody) {
                console.log("Player touched lava!");
                resetPlayerPosition();
            }
        }

        function resetPlayerPosition() {
            playerBody.position.set(CELL_SIZE * 1.5, PLAYER_HEIGHT, CELL_SIZE * 1.5);
            playerBody.velocity.set(0, 0, 0);
            controls.getObject().position.copy(playerBody.position);
            console.log("Player position reset:", playerBody.position);
        }

        function saveLabyrinth() {
            const data = JSON.stringify(matrix);
            const blob = new Blob([data], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'labyrinth.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadLabyrinth(event) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    const loadedMatrix = JSON.parse(e.target.result);
                    drawLabyrinth(loadedMatrix);
                };
                reader.readAsText(file);
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            try {
                world.step(timeStep);

                updatePlayerMovement(delta);
                syncPlayerWithPhysics();

                // Update orb positions
                labyrinth.children.forEach(child => {
                    if (child instanceof THREE.Mesh && child.geometry instanceof THREE.SphereGeometry) {
                        const direction = new THREE.Vector3().subVectors(playerBody.position, child.position).normalize();
                        child.position.add(direction.multiplyScalar(0.05)); // Adjust speed here
                        child.position.y = child.userData.initialY + Math.sin(time * 0.003) * 0.5;
                        child.userData.light.position.copy(child.position);
                    }
                });

                prevTime = time;
                renderer.render(scene, camera);
            } catch (error) {
                console.error("Error in animate function:", error);
            }
        }

        function updatePlayerMovement(delta) {
            direction.z = Number(moveForward) - Number(moveBackward);
            direction.x = Number(moveRight) - Number(moveLeft);
            direction.normalize();

            if (controls.isLocked) {
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
                const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);

                const moveDirection = new THREE.Vector3();
                moveDirection.addScaledVector(forward, direction.z);
                moveDirection.addScaledVector(right, direction.x);
                moveDirection.y = 0;
                moveDirection.normalize();

                const speed = sprint ? RUN_SPEED : WALK_SPEED;
                const moveImpulse = new CANNON.Vec3(
                    moveDirection.x * speed * delta,
                    0,
                    moveDirection.z * speed * delta
                );

                playerBody.applyImpulse(moveImpulse, playerBody.position);
            }

            if (canJump && controls.isLocked) {
                playerBody.velocity.y = JUMP_HEIGHT;
                canJump = false;
            }
        }

        function syncPlayerWithPhysics() {
            controls.getObject().position.copy(playerBody.position);
            
            if (playerBody.position.y < PLAYER_HEIGHT) {
                playerBody.position.y = PLAYER_HEIGHT;
                playerBody.velocity.y = 0;
                canJump = true;
            }
        }

        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = true;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = true;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = true;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = true;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    sprint = true;
                    break;
                case 'Space':
                    if (canJump) {
                        playerBody.velocity.y += JUMP_HEIGHT;
                        canJump = false;
                    }
                    break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp':
                case 'KeyW':
                    moveForward = false;
                    break;
                case 'ArrowLeft':
                case 'KeyA':
                    moveLeft = false;
                    break;
                case 'ArrowDown':
                case 'KeyS':
                    moveBackward = false;
                    break;
                case 'ArrowRight':
                case 'KeyD':
                    moveRight = false;
                    break;
                case 'ShiftLeft':
                case 'ShiftRight':
                    sprint = false;
                    break;
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleCollision() {
            collisionEnabled = !collisionEnabled;
            const button = document.getElementById('toggleCollisionBtn');
            button.textContent = collisionEnabled ? 'Disable Collision' : 'Enable Collision';
            button.style.background = collisionEnabled ? '#ff4136' : '#4CAF50';

            world.bodies.forEach(body => {
                body.collisionResponse = collisionEnabled;
            });
        }

        init();
    </script>
</body></html>
