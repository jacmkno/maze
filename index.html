
<!--
https://websim.ai/c/6VtVN0iSDlDgV3BIR 
Continue development on websim on new prompt with:
- See if you can start a web app from this code, leave the code as is... It already works.

Interesting prompts:
1. Place holes in the floor that you must jump to get over.   Also oscillating orbs of light in the path.
2. Now, the holes must be full of lethal lava.   The orbs must have different colors and they have to follow you very slowly. 

Creating an Orb:
https://chatgpt.com/c/66ebd04b-91c8-8005-be45-a9c56f4aa07c
-->
<html>
<head>
    <title>3D Labyrinth Explorer</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; }
        canvas { display: block; }
        #menu, #instructions {
            position: absolute; background: rgba(0,0,0,0.7); color: white;
            padding: 10px; border-radius: 5px;
        }
        #menu { top: 10px; left: 10px; }
        #instructions { bottom: 10px; left: 10px; }
        button {
            margin: 5px; padding: 5px 10px; background: #4CAF50; color: white;
            border: none; border-radius: 3px; cursor: pointer;
        }
        button:hover { background: #45a049; }
    </style>
    <!-- TODO: Move to threejs 169 (latest) -->
    <script type="importmap">{ "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.128.0/+esm",
            "PointerLockControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/PointerLockControls.js",
            "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js",
            "three/examples/jsm/postprocessing/EffectComposer": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/EffectComposer.js",
            "three/examples/jsm/postprocessing/RenderPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/RenderPass.js",
            "three/examples/jsm/postprocessing/ShaderPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/ShaderPass.js",
            "three/examples/jsm/postprocessing/GodRaysPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/GodRaysPass.js",
            "three/examples/jsm/postprocessing/UnrealBloomPass": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/postprocessing/UnrealBloomPass.js",
            "three/examples/jsm/shaders/CopyShader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/shaders/CopyShader.js",
            "three/examples/jsm/shaders/GodRaysShader": "https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/shaders/GodRaysShader.js",
            "game2": "https://jacmkno.github.io/maze/game.js",
            "game": "./game.js"
    } }</script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>
</head>
<body>
    <div id="menu" onclick="event.stopImmediatePropagation()">
        <button id="generateBtn">Generate New Labyrinth</button>
        <button id="saveBtn">Save Labyrinth</button>
        <button id="loadBtn">Load Labyrinth</button>
        <button id="toggleCollisionBtn">Disable Collision</button>
        <input type="file" id="fileInput" style="display:none;">
    </div>
    <div id="instructions">
        <p>Click to start | WASD or Arrow Keys: Move | Mouse: Look | Shift: Run | Space: Jump | ESC: Release mouse</p>
    </div>
    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer, EffectPass, RenderPass, GodRaysEffect } from 'https://cdn.jsdelivr.net/npm/postprocessing@6.36.3/+esm';


        import * as game from "game";
        class Config extends game.DefaultConfig {
            // Custom config settings
            static CUSTOM_SETTING = 10;
        }
        game.setConfig(Config);
    
        class Game extends game.Game {
            constructor() {
                super(false);
                //this.posprocess = this.getPostprocessingRenderer();
                this.animate();
            }
            render() {
                super.render();
                //this.posprocess();
            }

            getPostprocessingRenderer() {
                const composer = new EffectComposer(this.renderer);

                // Create a render pass
                const renderPass = new RenderPass(this.scene, this.camera);
                composer.addPass(renderPass);

                // Collect light meshes from light.userData.mesh
                const lightMeshes = [];
                const lightMeshMap = new Map(); // Map to track lights and their meshes

                this.scene.traverse((object) => {
                    if (object.isLight) {
                        const lightMesh = object.userData.mesh;
                        if (lightMesh) {
                            lightMeshes.push(lightMesh);
                            // Map the light to its mesh
                            lightMeshMap.set(object, lightMesh);
                        }
                    }
                });

                // Create God Rays effects for each light mesh
                const godRaysEffects = lightMeshes.map((lightMesh) => {
                    return new GodRaysEffect(this.camera, lightMesh, {
                        resolutionScale: 1.0,
                        density: 0.96,
                        decay: 0.93,
                        weight: 0.4,
                        samples: 30, // Adjust for performance if needed
                        clampMax: 1.0
                    });
                });

                // Combine the effects into one EffectPass
                const effectPass = new EffectPass(this.camera, ...godRaysEffects);
                effectPass.renderToScreen = true;
                composer.addPass(effectPass);

                // Handle window resize
                window.addEventListener('resize', () => {
                    composer.setSize(window.innerWidth, window.innerHeight);
                });

                // Update function to keep light meshes in sync
                this.updateLightMeshes = () => {
                    lightMeshMap.forEach((lightMesh, light) => {
                        lightMesh.position.copy(light.position);
                    });
                };

                return () => {
                    this.updateLightMeshes(); // Update light mesh positions
                    composer.render();
                };
            }
        }
    
        Game.start();
    </script>    
</body>
</html>